\newcommand{\deff} [2] {\uppercase{\scriptsize #1} {\tiny #2}}
%Feedback ^ this is a latex macro.
% it is called with the command `deff` and takes 2 arguments,
% \deff{nFeedbaceame}{means this} => NAME means this 
%  ^    ^     ^ the definition
%  |    |what to define
%  |command name
\section{Definitions}

% Lecture 1

\deff{OS}{A virtual machine, resource allocator, and control program whos goal
is the comfort of the user and then efficienty of operations}

\deff{Interrupts}{A hardware signal that causes the CPU to jump to a predefined
instruction called the \textit{interrupt handler}}

\deff{Mode Bit}{Allows for dual mode operations, like \textit{user mode} and
\textit{system mode}, where there are privileged instructions, such as (en/dis)abilng
interrupts, halting CPI, writing to registers, etc.}

\deff{Process}{A program in execution. A program has potential for execution.
Contains the state of a program}

\deff{PCB}{(Process Control Blockr) Contains state, program counter, cpu
registers/scheduling info, i/o info, etc}

\deff{Context Switch}{switching the cpu to another process by saving the state
of the old one and loading the saved state for the new proccess. this happens
only when a process calls yield(), makes a syscall, or the timer decides to
switch}

\deff{Zombie}{A process that has not been cleaned up by its parent}

% =================Lecture 2==========================
\deff{System Call}{a function call that invokes the operating system}

\deff{independent}{a process that cannot affect or be affected by other process (no data sharing)}

\deff{cooperating}{a process that is not independent}

\deff{thread}{a control flow through a program}

\deff{multithreaded}{a program with multiple control flows}

% =================Lecture 3==========================
\deff{race condition}{when the outcome depends on the order of execution}

\deff{mutual exclusion}{one thread in the critical section (CS) $\implies$ no other is}

\deff{progress}{No thread in CS, $\exists T \in Threads, T$ wants to enter CS $\implies T$ enters, regardless of what is in remaineder}

\deff{bounded waiting}{There is an upper bound on the number of threads that
enter the CS before a thread that wants to enter goes in}

\deff{Performance}{(Threads) the overhead of entering/exiting CS is small
w.r.t work being done in it.}

\deff{atomic}{An instruction that cannot be interupted. If two instructions
are executed concurrently, the result is equivalent to the sequential
execution in an unknown order} 

% =================Lecture 4==========================
\deff{Condition Variable}{an ADT that encapsulates the pattern: release mutex,
sleep, re-acquire mutex}

\deff{Monitor}{an ADT with the restriction that only one process at a time can
be active within the monitor}

\deff{Hoare Monitor}{ {\tt signal()} immediately switches from caller to a
waiting thread, condition that waiter was blocked on is guaranteed to hold when
waiter resumes. Needs another queue for the signaler if signaler was not done
using monitor}

\deff{Mesa monitors}{ {\tt signal()} places a waiter on the ready queue, but
signaler continues inside monitor. The condition is not necessarily true when
the waiter resumes, and the condition must be checked again. Uses a while loop
}

\deff{priority inversion}{a low priority task preventing a high priority task
from making progress by holding a resource}

\deff{starvation}{a task that does not get to run; a thread is suffering from
starvation if it is waiting indefinitely because other threads are in some way
preferred}

% =================Lecture 6==========================
\deff{internal fragmentation}{the result of a process not using all the memory given to it}

\deff{overlays}{when a program needs more memory than partition size}

\deff{external fragmentation}{memory ``holes'' created by exiting processes
that are too small to re-use}

\deff{compaction}{moving processes around to create larger chunks of free space}

\deff{page fault}{when a page requested is not in memory}

\deff{temporal locality}{locations referenced recently are likely to be referenced again}

\deff{spatial locality}{locations near recently referenced locations are likely to be referenced again}

\deff{COW}{(copy on write) give a reference to the page until a write is made,
then make room for it}

% =================Lecture 7==========================
\deff{TLB}{(Translation lookaside buffer) small, fully associative hardware
cache of recently used translations that is part of MMU}


% =================Lecture 8==========================
\deff{Thrashing}{is when the OS spends more time paging data back and
forth (from disk) than executing user programs, we then say the os is overcommited}

% =================Lecture 12=========================
\deff{deadlock}{the permanent blocking of a set of processes that either
compete for system resources or communicate with each other. necessarily
requires mutual
exclusion, hold and wait, no preemption, and sufficiently circular wait;
threads are in a deadlocked state when every thread in the set is waiting for
an event that can be caused only by another thread in the set} 

\deff{resource}{any object that might be needed by a process to do its owrk, like hardware, data, object, etc}
\deff{atomicity violation bug}{code region that is intended to be atomic, but
atomicity not enforced during execution.}

\deff{order violation}{when the desired order between meemory accesses is
flipped (order is assumed but not enforced)}

\deff{transaction}{a collection of operations that performs a single logical
function (sequence of read/write, terminated by commit/abort)}

\deff{committed}{a transaction that has completed successfully; committed => cannoted be undone}

\deff{aborted}{a transaction that did not complete normally; rollback and start again}

\deff{operation conflict}{two diff.\ transactions conflict if both acess the
same data item and at least one of them is a write}

\deff{consumable resources}{messages between communicating processes}

\deff{growing}{wrt serializability, transaction obtaining, but not releasing,
locks.}

\deff{shrinking}{wrt serializability,  a transaction releasing lock, but not acquiring}.
